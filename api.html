

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>API Reference &mdash; context 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/togglebutton.css" type="text/css" />
  <link rel="stylesheet" href="_static/mystnb.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/togglebutton.js"></script>
        <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Internal" href="internal.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
          

          
            <a href="index.html" class="icon icon-home"> context
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quick_start.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="task.html">Task</a></li>
<li class="toctree-l1"><a class="reference internal" href="executor.html">Executor</a></li>
<li class="toctree-l1"><a class="reference internal" href="internal.html">Internal</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-flowsaber.cli">cli</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-flowsaber.core.task">task</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-flowsaber.core.operators">operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-flowsaber.tasks.shell">shell</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-flowsaber.core.flow">flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-flowsaber.core.base">base</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-flowsaber.core.context">context</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-flowsaber.core.channel">channel</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-flowsaber.core.utility.state">state</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-flowsaber.core.utility.cache">cache</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-flowsaber.core.utility.target">target</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-flowsaber.core.utility.executor">executor</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-flowsaber.core.engine.runner">runner</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-flowsaber.core.engine.task_runner">task_runner</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-flowsaber.core.engine.flow_runner">flow_runner</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-flowsaber.server.database.models">models</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">context</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>API Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-flowsaber.cli">
<span id="cli"></span><h2>cli<a class="headerlink" href="#module-flowsaber.cli" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-flowsaber.core.task">
<span id="task"></span><h2>task<a class="headerlink" href="#module-flowsaber.core.task" title="Permalink to this headline">¶</a></h2>
<p><strong>Classes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTask</span></code>([num_out])</p></td>
<td><p>Base class of all Tasks, internally, BaseTask iteratively fetch items emitted by Channel inputs asynchronously.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Edge</span></code>(channel, task)</p></td>
<td><p>A edge represents a dependency between a channel and a task.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RunTask</span></code>([num_out])</p></td>
<td><p>RunTask is subclass of BaseTask, representing tasks with run method exposed to users to implement specific item processing logics.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Task</span></code>(**kwargs)</p></td>
<td><p>Task is subclass of RunTask: 1.</p></td>
</tr>
</tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RunDataFileNotFoundError</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RunDataTypeError</span></code></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="flowsaber.core.task.BaseTask">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.task.</code><code class="sig-name descname">BaseTask</code><span class="sig-paren">(</span><em class="sig-param">num_out: int = 1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.BaseTask" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class of all Tasks, internally, BaseTask iteratively fetch items emitted by Channel inputs asynchronously.
And then push the processed result of each item into the _output channels. All items are handled in sequence.</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">enqueue_res</span></code>(data[, index])</p></td>
<td><p>Enqueue processed data into _output channels.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_consumer</span></code>(consumer, **kwargs)</p></td>
<td><p>Iteratively fetch data from consumer and then call processing function</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_input</span></code>(data, *args, **kwargs)</p></td>
<td><p>Do nothing, send the _input data directly to _output channel Parameters ———- data args kwargs</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_context</span></code>()</p></td>
<td><p>Initialize some attributes of self.config into self.context</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_input</span></code>(*args, **kwargs)</p></td>
<td><p>Wrap all _input channels into a consumer object for simultaneous data ferching,</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_output</span></code>()</p></td>
<td><p>Create _output channels according to self.num_output</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.task.BaseTask.enqueue_res">
<em class="property">async </em><code class="sig-name descname">enqueue_res</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.BaseTask.enqueue_res" title="Permalink to this definition">¶</a></dt>
<dd><p>Enqueue processed data into _output channels.
Parameters
———-
data
index</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.BaseTask.handle_consumer">
<em class="property">async </em><code class="sig-name descname">handle_consumer</code><span class="sig-paren">(</span><em class="sig-param">consumer: flowsaber.core.channel.Consumer</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.BaseTask.handle_consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>Iteratively fetch data from consumer and then call processing function</p>
<p>consumer
kwargs</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.BaseTask.handle_input">
<em class="property">async </em><code class="sig-name descname">handle_input</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.BaseTask.handle_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing, send the _input data directly to _output channel
Parameters
———-
data
args
kwargs</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.BaseTask.initialize_context">
<code class="sig-name descname">initialize_context</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.BaseTask.initialize_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize some attributes of self.config into self.context</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.BaseTask.initialize_input">
<code class="sig-name descname">initialize_input</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.BaseTask.initialize_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap all _input channels into a consumer object for simultaneous data ferching,</p>
<p>args
kwargs</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.BaseTask.initialize_output">
<code class="sig-name descname">initialize_output</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.BaseTask.initialize_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Create _output channels according to self.num_output</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.task.Edge">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.task.</code><code class="sig-name descname">Edge</code><span class="sig-paren">(</span><em class="sig-param">channel: flowsaber.core.channel.Channel</em>, <em class="sig-param">task: flowsaber.core.task.BaseTask</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.Edge" title="Permalink to this definition">¶</a></dt>
<dd><p>A edge represents a dependency between a channel and a task. the Task consumes data emited by the channel.</p>
</dd></dl>

<dl class="exception">
<dt id="flowsaber.core.task.RunDataFileNotFoundError">
<em class="property">exception </em><code class="sig-prename descclassname">flowsaber.core.task.</code><code class="sig-name descname">RunDataFileNotFoundError</code><a class="headerlink" href="#flowsaber.core.task.RunDataFileNotFoundError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="exception">
<dt id="flowsaber.core.task.RunDataTypeError">
<em class="property">exception </em><code class="sig-prename descclassname">flowsaber.core.task.</code><code class="sig-name descname">RunDataTypeError</code><a class="headerlink" href="#flowsaber.core.task.RunDataTypeError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="flowsaber.core.task.RunTask">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.task.</code><code class="sig-name descname">RunTask</code><span class="sig-paren">(</span><em class="sig-param">num_out: int = 1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.RunTask" title="Permalink to this definition">¶</a></dt>
<dd><p>RunTask is subclass of BaseTask, representing tasks with run method exposed to users to implement specific
item processing logics.
Compared to BaseTask:
1. Runs of multiple inputs will be executed in parallel.
2. Runs will be executed in the main loop.</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">call_run</span></code>(data, **kwargs)</p></td>
<td><p>Create a fresh task object and call it’s run method for real data processing.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_run_data</span></code>(data, **kwargs)</p></td>
<td><p>Match types of _input datas into self.run’s annotations by type conversion.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_run_data</span></code>(data)</p></td>
<td><p>Wrap consumer fetched data tuple into a BoundArgument paired with self.run’s signature.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_consumer</span></code>(consumer, **kwargs)</p></td>
<td><p>Run processing functions in parallel by submitting jobs into schedulers that return awaitable Future-like objects.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_run_data</span></code>(data, **kwargs)</p></td>
<td><p>This coroutine will be executed in parallel, thus need to re-enter self.context.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_context</span></code>()</p></td>
<td><p>Expose cache_type and executor_type into self.context</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code>(*args, **kwargs)</p></td>
<td><p>The method users need to implement for processing the data emited by _input channels.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.task.RunTask.call_run">
<em class="property">async </em><code class="sig-name descname">call_run</code><span class="sig-paren">(</span><em class="sig-param">data: inspect.BoundArguments</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.RunTask.call_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a fresh task object and call it’s run method for real data processing.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.RunTask.check_run_data">
<em class="property">async </em><code class="sig-name descname">check_run_data</code><span class="sig-paren">(</span><em class="sig-param">data: inspect.BoundArguments</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.RunTask.check_run_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Match types of _input datas into self.run’s annotations by type conversion. Check file integrity.
Parameters
———-
data
kwargs</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.RunTask.create_run_data">
<code class="sig-name descname">create_run_data</code><span class="sig-paren">(</span><em class="sig-param">data: Union[tuple, flowsaber.core.utility.target.End]</em><span class="sig-paren">)</span> &#x2192; inspect.BoundArguments<a class="headerlink" href="#flowsaber.core.task.RunTask.create_run_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap consumer fetched data tuple into a BoundArgument paired with self.run’s signature.
Parameters
———-
data</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.RunTask.handle_consumer">
<em class="property">async </em><code class="sig-name descname">handle_consumer</code><span class="sig-paren">(</span><em class="sig-param">consumer: flowsaber.core.channel.Consumer</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.RunTask.handle_consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>Run processing functions in parallel by submitting jobs into schedulers that
return awaitable Future-like objects.
Parameters
———-
consumer
kwargs</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.RunTask.handle_run_data">
<em class="property">async </em><code class="sig-name descname">handle_run_data</code><span class="sig-paren">(</span><em class="sig-param">data: inspect.BoundArguments</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.RunTask.handle_run_data" title="Permalink to this definition">¶</a></dt>
<dd><p>This coroutine will be executed in parallel, thus need to re-enter self.context.
Parameters
———-
data
kwargs</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.RunTask.initialize_context">
<code class="sig-name descname">initialize_context</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.RunTask.initialize_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Expose cache_type and executor_type into self.context</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.RunTask.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.RunTask.run" title="Permalink to this definition">¶</a></dt>
<dd><p>The method users need to implement for processing the data emited by _input channels.
Parameters
———-
args
kwargs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.task.Task">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.task.</code><code class="sig-name descname">Task</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.Task" title="Permalink to this definition">¶</a></dt>
<dd><p>Task is subclass of RunTask:
1. Each Task will have a unique task_key/task_workdir
2. Each _input’s run will have a unique run_key/task_workdir.
3. Task’s run will be executed in executor and handled by a task runner.
4. Within the task runner, task will pass through a state machine, callbacks can be registered to each state changes.</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">call_run</span></code>(data, **kwargs)</p></td>
<td><p>Call self.run within the control of a asyncio.Lock identified by run_workdir Parameters ———- data kwargs</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clean</span></code>()</p></td>
<td><p>Functions called after the execution of task.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_res</span></code>(res)</p></td>
<td><p>Only push Success state result into _output channels.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_context</span></code>()</p></td>
<td><p>Expose cache_type and executor_type into self.context</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">need_skip</span></code>(data)</p></td>
<td><p>Check if the _input can be directly passed into _output channels by predicate of user specified self.skip_fn Parameters ———- data</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">skip</span></code>(skip_fn)</p></td>
<td><p>A decorator/function exposed for users to specify skip function.</p></td>
</tr>
</tbody>
</table>
<p><strong>Attributes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">task_hash</span></code></p></td>
<td><p>get the task_hash of this task defined by the real source code of self.run</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">task_workdir</span></code></p></td>
<td><p>Task’s workdir is resolved in a bottom up way.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.task.Task.call_run">
<em class="property">async </em><code class="sig-name descname">call_run</code><span class="sig-paren">(</span><em class="sig-param">data: inspect.BoundArguments</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span> &#x2192; flowsaber.core.utility.state.State<a class="headerlink" href="#flowsaber.core.task.Task.call_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Call self.run within the control of a asyncio.Lock identified by run_workdir
Parameters
———-
data
kwargs</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.Task.clean">
<code class="sig-name descname">clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.Task.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>Functions called after the execution of task. For example, Cache need to persist cached data.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.Task.handle_res">
<em class="property">async </em><code class="sig-name descname">handle_res</code><span class="sig-paren">(</span><em class="sig-param">res</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.Task.handle_res" title="Permalink to this definition">¶</a></dt>
<dd><p>Only push Success state result into _output channels. Some state may be skipped in case of
Exceptions occurred within the task runner and thus return a Drop(Failure) state as a signal.
Parameters
———-
res</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.Task.initialize_context">
<code class="sig-name descname">initialize_context</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.Task.initialize_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Expose cache_type and executor_type into self.context</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.Task.need_skip">
<code class="sig-name descname">need_skip</code><span class="sig-paren">(</span><em class="sig-param">data: inspect.BoundArguments</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#flowsaber.core.task.Task.need_skip" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the _input can be directly passed into _output channels by predicate of user specified self.skip_fn
Parameters
———-
data</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.Task.skip">
<code class="sig-name descname">skip</code><span class="sig-paren">(</span><em class="sig-param">skip_fn: Callable</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.task.Task.skip" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator/function exposed for users to specify skip function.</p>
<p>skip_fn</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.Task.task_hash">
<em class="property">property </em><code class="sig-name descname">task_hash</code><a class="headerlink" href="#flowsaber.core.task.Task.task_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>get the task_hash of this task defined by the real source code of self.run</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.task.Task.task_workdir">
<em class="property">property </em><code class="sig-name descname">task_workdir</code><a class="headerlink" href="#flowsaber.core.task.Task.task_workdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Task’s workdir is resolved in a bottom up way.
In this hierarchical way, users can change flowrun.context[‘flow_workdir’] by setting up the flowrun’s
initial context, thus make the flow’s workdir configurable.</p>
<p>1: if the task_workdir is already absolute, then use it
2: if parent_flow_workdir/task_workdir is already absolute, then use it
3: otherwise use top_flow_workdir/parent_flow_workdir/task_workdir as the workdir</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-flowsaber.core.operators">
<span id="operators"></span><h2>operators<a class="headerlink" href="#module-flowsaber.core.operators" title="Permalink to this headline">¶</a></h2>
<p><strong>Classes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Branch" title="flowsaber.core.operators.Branch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Branch</span></code></a>(num, by, **kwargs)</p></td>
<td><p>Dispatch _input into specified number of channels base on the returned index of the predicate function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.operators.Collect" title="flowsaber.core.operators.Collect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Collect</span></code></a>([num_out])</p></td>
<td><p>Opposite to flatten, turns a channel into a tuple</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Concat" title="flowsaber.core.operators.Concat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Concat</span></code></a>([num_out])</p></td>
<td><p>Data in channels are concatenated in the order of _input channels.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.operators.Count" title="flowsaber.core.operators.Count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Count</span></code></a>(**kwargs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Distinct" title="flowsaber.core.operators.Distinct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distinct</span></code></a>(**kwargs)</p></td>
<td><p>Remove continuously duplicated item.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.operators.Filter" title="flowsaber.core.operators.Filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Filter</span></code></a>([by])</p></td>
<td><p>Filter item by the predicate function or the comparing identity.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.First" title="flowsaber.core.operators.First"><code class="xref py py-obj docutils literal notranslate"><span class="pre">First</span></code></a>(**kwargs)</p></td>
<td><p>Take the first item</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.operators.Flatten" title="flowsaber.core.operators.Flatten"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Flatten</span></code></a>([max_level])</p></td>
<td><p>Flatten the _output of channel.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.GetItem" title="flowsaber.core.operators.GetItem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GetItem</span></code></a>(key, **kwargs)</p></td>
<td><p>Get item from the output of the input channel with specified key, like <cite>obj[key]</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.operators.Group" title="flowsaber.core.operators.Group"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Group</span></code></a>([by, num, keep])</p></td>
<td><p>return a new channel with item of Tuple(key_fn(_input), grouped_data_tuple), the group size can be specified.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Last" title="flowsaber.core.operators.Last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Last</span></code></a>(**kwargs)</p></td>
<td><p>Take the last item</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.operators.Map" title="flowsaber.core.operators.Map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Map</span></code></a>(by, **kwargs)</p></td>
<td><p>Map each item to another item return by the specified map function into a new channel.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Max" title="flowsaber.core.operators.Max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Max</span></code></a>([result])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.operators.Merge" title="flowsaber.core.operators.Merge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Merge</span></code></a>([num_out])</p></td>
<td><p>Merge channels into a channel with _output of tuple.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Min" title="flowsaber.core.operators.Min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Min</span></code></a>([result])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.operators.Mix" title="flowsaber.core.operators.Mix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Mix</span></code></a>([num_out])</p></td>
<td><p>Data emitted bu channels are mixed into a single channel.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Operator" title="flowsaber.core.operators.Operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Operator</span></code></a>([num_out])</p></td>
<td><p>Base class for all operators, subclass of BaseTask, all operators runs in the main loop in sequence and do not have runners and run states.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.operators.Reduce" title="flowsaber.core.operators.Reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Reduce</span></code></a>(by[, result])</p></td>
<td><p>Similar to normal reduce.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Sample" title="flowsaber.core.operators.Sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sample</span></code></a>([num])</p></td>
<td><p>Randomly sample at most <cite>num</cite> number of _input emitted by the channel using reservoir algorithm(should visit all elements.).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.operators.Select" title="flowsaber.core.operators.Select"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Select</span></code></a>(key, **kwargs)</p></td>
<td><p>Alias for GetItem task.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Split" title="flowsaber.core.operators.Split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Split</span></code></a>(num, **kwargs)</p></td>
<td><p>Used when _output is tuple/list, use split to split each item of the tuple into a unique channel.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.operators.Subscribe" title="flowsaber.core.operators.Subscribe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Subscribe</span></code></a>([on_next, on_complete])</p></td>
<td><p>specify on_next or on_complete function as callbacks of these two event.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Sum" title="flowsaber.core.operators.Sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sum</span></code></a>(**kwargs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.operators.Take" title="flowsaber.core.operators.Take"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Take</span></code></a>([num])</p></td>
<td><p>Only take the first <cite>num</cite> number of items</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Unique" title="flowsaber.core.operators.Unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Unique</span></code></a>(**kwargs)</p></td>
<td><p>Emit items at most once(no duplicate).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.operators.Until" title="flowsaber.core.operators.Until"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Until</span></code></a>(by, **kwargs)</p></td>
<td><p>“Take items until meet a stop marker.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.View" title="flowsaber.core.operators.View"><code class="xref py py-obj docutils literal notranslate"><span class="pre">View</span></code></a>(**kwargs)</p></td>
<td><p>Print each item emitted by the channel, Equals to call Subscribe(on_next=print)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.operators.var" title="flowsaber.core.operators.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code></a></p></td>
<td><p>alias of <a class="reference internal" href="#flowsaber.core.operators.Count" title="flowsaber.core.operators.Count"><code class="xref py py-class docutils literal notranslate"><span class="pre">flowsaber.core.operators.Count</span></code></a></p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="flowsaber.core.operators.Branch">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Branch</code><span class="sig-paren">(</span><em class="sig-param">num: int</em>, <em class="sig-param">by: Callable</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Branch" title="Permalink to this definition">¶</a></dt>
<dd><p>Dispatch _input into specified number of channels base on the returned index of the predicate function.</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Branch.handle_consumer" title="flowsaber.core.operators.Branch.handle_consumer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_consumer</span></code></a>(consumer, **kwargs)</p></td>
<td><p>Iteratively fetch data from consumer and then call processing function</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.operators.Branch.handle_consumer">
<em class="property">async </em><code class="sig-name descname">handle_consumer</code><span class="sig-paren">(</span><em class="sig-param">consumer: flowsaber.core.channel.Consumer</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Branch.handle_consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>Iteratively fetch data from consumer and then call processing function</p>
<p>consumer
kwargs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Collect">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Collect</code><span class="sig-paren">(</span><em class="sig-param">num_out: int = 1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Collect" title="Permalink to this definition">¶</a></dt>
<dd><p>Opposite to flatten, turns a channel into a tuple</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Collect.handle_consumer" title="flowsaber.core.operators.Collect.handle_consumer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_consumer</span></code></a>(consumer, **kwargs)</p></td>
<td><p>Iteratively fetch data from consumer and then call processing function</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.operators.Collect.handle_consumer">
<em class="property">async </em><code class="sig-name descname">handle_consumer</code><span class="sig-paren">(</span><em class="sig-param">consumer: flowsaber.core.channel.Consumer</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Collect.handle_consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>Iteratively fetch data from consumer and then call processing function</p>
<p>consumer
kwargs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Concat">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Concat</code><span class="sig-paren">(</span><em class="sig-param">num_out: int = 1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Data in channels are concatenated in the order of _input channels.</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Concat.handle_consumer" title="flowsaber.core.operators.Concat.handle_consumer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_consumer</span></code></a>(consumer, **kwargs)</p></td>
<td><p>Iteratively fetch data from consumer and then call processing function</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.operators.Concat.handle_consumer">
<em class="property">async </em><code class="sig-name descname">handle_consumer</code><span class="sig-paren">(</span><em class="sig-param">consumer: flowsaber.core.channel.Consumer</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Concat.handle_consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>Iteratively fetch data from consumer and then call processing function</p>
<p>consumer
kwargs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Count">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Count</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Count" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Distinct">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Distinct</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Distinct" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove continuously duplicated item.</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Filter">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Filter</code><span class="sig-paren">(</span><em class="sig-param">by: Union[Callable[[Any], bool], object] = &lt;function Filter.&lt;lambda&gt;&gt;, **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter item by the predicate function or the comparing identity.</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Filter.handle_input" title="flowsaber.core.operators.Filter.handle_input"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_input</span></code></a>(data, *args, **kwargs)</p></td>
<td><p>Do nothing, send the _input data directly to _output channel Parameters ———- data args kwargs</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.operators.Filter.handle_input">
<em class="property">async </em><code class="sig-name descname">handle_input</code><span class="sig-paren">(</span><em class="sig-param">data: Union[tuple, flowsaber.core.utility.target.End], *args, **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Filter.handle_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing, send the _input data directly to _output channel
Parameters
———-
data
args
kwargs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.First">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">First</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.First" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the first item</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Flatten">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Flatten</code><span class="sig-paren">(</span><em class="sig-param">max_level: int = None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Flatten the _output of channel.</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Flatten.handle_input" title="flowsaber.core.operators.Flatten.handle_input"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_input</span></code></a>(data, *args, **kwargs)</p></td>
<td><p>Do nothing, send the _input data directly to _output channel Parameters ———- data args kwargs</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.operators.Flatten.handle_input">
<em class="property">async </em><code class="sig-name descname">handle_input</code><span class="sig-paren">(</span><em class="sig-param">data: Union[tuple, flowsaber.core.utility.target.End], *args, **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Flatten.handle_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing, send the _input data directly to _output channel
Parameters
———-
data
args
kwargs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.GetItem">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">GetItem</code><span class="sig-paren">(</span><em class="sig-param">key: Any</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.GetItem" title="Permalink to this definition">¶</a></dt>
<dd><p>Get item from the output of the input channel with specified key, like <cite>obj[key]</cite>. The input channel is excepted
to emit objects with <cite>__getitem__</cite> method. For example, tuple, list, dict ….</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.GetItem.handle_input" title="flowsaber.core.operators.GetItem.handle_input"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_input</span></code></a>(data, *args, **kwargs)</p></td>
<td><p>Do nothing, send the _input data directly to _output channel Parameters ———- data args kwargs</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.operators.GetItem.handle_input">
<em class="property">async </em><code class="sig-name descname">handle_input</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.GetItem.handle_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing, send the _input data directly to _output channel
Parameters
———-
data
args
kwargs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Group">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Group</code><span class="sig-paren">(</span><em class="sig-param">by: Callable = &lt;function Group.&lt;lambda&gt;&gt;</em>, <em class="sig-param">num: int = inf</em>, <em class="sig-param">keep: bool = True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Group" title="Permalink to this definition">¶</a></dt>
<dd><p>return a new channel with item of Tuple(key_fn(_input), grouped_data_tuple),
the group size can be specified.</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Group.handle_input" title="flowsaber.core.operators.Group.handle_input"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_input</span></code></a>(data, *args, **kwargs)</p></td>
<td><p>Do nothing, send the _input data directly to _output channel Parameters ———- data args kwargs</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.operators.Group.handle_input">
<em class="property">async </em><code class="sig-name descname">handle_input</code><span class="sig-paren">(</span><em class="sig-param">data: Union[tuple, flowsaber.core.utility.target.End], *args, **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Group.handle_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing, send the _input data directly to _output channel
Parameters
———-
data
args
kwargs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Last">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Last</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Last" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the last item</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Last.handle_input" title="flowsaber.core.operators.Last.handle_input"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_input</span></code></a>(data, *args, **kwargs)</p></td>
<td><p>Do nothing, send the _input data directly to _output channel Parameters ———- data args kwargs</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.operators.Last.handle_input">
<em class="property">async </em><code class="sig-name descname">handle_input</code><span class="sig-paren">(</span><em class="sig-param">data: Union[tuple, flowsaber.core.utility.target.End], *args, **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Last.handle_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing, send the _input data directly to _output channel
Parameters
———-
data
args
kwargs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Map">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Map</code><span class="sig-paren">(</span><em class="sig-param">by: Callable</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Map" title="Permalink to this definition">¶</a></dt>
<dd><p>Map each item to another item return by the specified map function into a new channel.</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Map.handle_input" title="flowsaber.core.operators.Map.handle_input"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_input</span></code></a>(data, *args, **kwargs)</p></td>
<td><p>Do nothing, send the _input data directly to _output channel Parameters ———- data args kwargs</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.operators.Map.handle_input">
<em class="property">async </em><code class="sig-name descname">handle_input</code><span class="sig-paren">(</span><em class="sig-param">data: Union[tuple, flowsaber.core.utility.target.End], *args, **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Map.handle_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing, send the _input data directly to _output channel
Parameters
———-
data
args
kwargs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Max">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Max</code><span class="sig-paren">(</span><em class="sig-param">result: float = -inf</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Merge">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Merge</code><span class="sig-paren">(</span><em class="sig-param">num_out: int = 1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge channels into a channel with _output of tuple.
Even if there is only one channel _input, always _output a tuple</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Min">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Min</code><span class="sig-paren">(</span><em class="sig-param">result: float = inf</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Mix">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Mix</code><span class="sig-paren">(</span><em class="sig-param">num_out: int = 1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Mix" title="Permalink to this definition">¶</a></dt>
<dd><p>Data emitted bu channels are mixed into a single channel.</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Mix.handle_consumer" title="flowsaber.core.operators.Mix.handle_consumer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_consumer</span></code></a>(consumer, **kwargs)</p></td>
<td><p>Iteratively fetch data from consumer and then call processing function</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.operators.Mix.handle_consumer">
<em class="property">async </em><code class="sig-name descname">handle_consumer</code><span class="sig-paren">(</span><em class="sig-param">consumer: flowsaber.core.channel.Consumer</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Mix.handle_consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>Iteratively fetch data from consumer and then call processing function</p>
<p>consumer
kwargs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Operator">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Operator</code><span class="sig-paren">(</span><em class="sig-param">num_out: int = 1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all operators, subclass of BaseTask, all operators runs in the main loop in sequence
and do not have runners and run states.</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Reduce">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Reduce</code><span class="sig-paren">(</span><em class="sig-param">by: Callable[[Any, Any], Any], result=&lt;object object&gt;, **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to normal reduce. results = f(n, f(n - 1))</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Reduce.handle_input" title="flowsaber.core.operators.Reduce.handle_input"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_input</span></code></a>(data, *args, **kwargs)</p></td>
<td><p>Do nothing, send the _input data directly to _output channel Parameters ———- data args kwargs</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.operators.Reduce.handle_input">
<em class="property">async </em><code class="sig-name descname">handle_input</code><span class="sig-paren">(</span><em class="sig-param">data: Union[tuple, flowsaber.core.utility.target.End], *args, **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Reduce.handle_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing, send the _input data directly to _output channel
Parameters
———-
data
args
kwargs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Sample">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Sample</code><span class="sig-paren">(</span><em class="sig-param">num: int = 1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly sample at most <cite>num</cite> number of _input emitted by the channel
using reservoir algorithm(should visit all elements.).</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Sample.handle_consumer" title="flowsaber.core.operators.Sample.handle_consumer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_consumer</span></code></a>(consumer, **kwargs)</p></td>
<td><p>Iteratively fetch data from consumer and then call processing function</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.operators.Sample.handle_consumer">
<em class="property">async </em><code class="sig-name descname">handle_consumer</code><span class="sig-paren">(</span><em class="sig-param">consumer: flowsaber.core.channel.Consumer</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Sample.handle_consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>Iteratively fetch data from consumer and then call processing function</p>
<p>consumer
kwargs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Select">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Select</code><span class="sig-paren">(</span><em class="sig-param">key: Any</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Select" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for GetItem task.</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Split">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Split</code><span class="sig-paren">(</span><em class="sig-param">num: int</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Split" title="Permalink to this definition">¶</a></dt>
<dd><p>Used when _output is tuple/list, use split to split each item of the tuple into a unique channel.</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Subscribe">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Subscribe</code><span class="sig-paren">(</span><em class="sig-param">on_next: Callable = None</em>, <em class="sig-param">on_complete: Callable = None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Subscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>specify on_next or on_complete function as callbacks of these two event.</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Subscribe.handle_consumer" title="flowsaber.core.operators.Subscribe.handle_consumer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_consumer</span></code></a>(consumer, **kwargs)</p></td>
<td><p>Iteratively fetch data from consumer and then call processing function</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.operators.Subscribe.handle_consumer">
<em class="property">async </em><code class="sig-name descname">handle_consumer</code><span class="sig-paren">(</span><em class="sig-param">consumer: flowsaber.core.channel.Consumer</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Subscribe.handle_consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>Iteratively fetch data from consumer and then call processing function</p>
<p>consumer
kwargs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Sum">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Sum</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Sum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Take">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Take</code><span class="sig-paren">(</span><em class="sig-param">num: int = 1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Take" title="Permalink to this definition">¶</a></dt>
<dd><p>Only take the first <cite>num</cite> number of items</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Take.handle_input" title="flowsaber.core.operators.Take.handle_input"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_input</span></code></a>(data, *args, **kwargs)</p></td>
<td><p>Do nothing, send the _input data directly to _output channel Parameters ———- data args kwargs</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.operators.Take.handle_input">
<em class="property">async </em><code class="sig-name descname">handle_input</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Take.handle_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing, send the _input data directly to _output channel
Parameters
———-
data
args
kwargs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Unique">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Unique</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Emit items at most once(no duplicate).</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.Until">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">Until</code><span class="sig-paren">(</span><em class="sig-param">by: Union[Callable[[Any], bool], object], **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Until" title="Permalink to this definition">¶</a></dt>
<dd><p>“Take items until meet a stop marker. the stop item will not be included</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.operators.Until.handle_input" title="flowsaber.core.operators.Until.handle_input"><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_input</span></code></a>(data, *args, **kwargs)</p></td>
<td><p>Do nothing, send the _input data directly to _output channel Parameters ———- data args kwargs</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.operators.Until.handle_input">
<em class="property">async </em><code class="sig-name descname">handle_input</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.Until.handle_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing, send the _input data directly to _output channel
Parameters
———-
data
args
kwargs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.operators.View">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">View</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.operators.View" title="Permalink to this definition">¶</a></dt>
<dd><p>Print each item emitted by the channel, Equals to call Subscribe(on_next=print)</p>
</dd></dl>

<dl class="attribute">
<dt id="flowsaber.core.operators.var">
<code class="sig-prename descclassname">flowsaber.core.operators.</code><code class="sig-name descname">var</code><a class="headerlink" href="#flowsaber.core.operators.var" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#flowsaber.core.operators.Count" title="flowsaber.core.operators.Count"><code class="xref py py-class docutils literal notranslate"><span class="pre">flowsaber.core.operators.Count</span></code></a></p>
</dd></dl>

</div>
<div class="section" id="module-flowsaber.tasks.shell">
<span id="shell"></span><h2>shell<a class="headerlink" href="#module-flowsaber.tasks.shell" title="Permalink to this headline">¶</a></h2>
<p><strong>Classes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.tasks.shell.CommandTask" title="flowsaber.tasks.shell.CommandTask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CommandTask</span></code></a>(**kwargs)</p></td>
<td><p>Task used for composing bash command based on outputs data of channels.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.tasks.shell.ShellFlow" title="flowsaber.tasks.shell.ShellFlow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ShellFlow</span></code></a>(**kwargs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.tasks.shell.ShellTask" title="flowsaber.tasks.shell.ShellTask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ShellTask</span></code></a>(**kwargs)</p></td>
<td><p>Task that execute bash command by using subprocess.</p></td>
</tr>
</tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.tasks.shell.CommandTaskComposeError" title="flowsaber.tasks.shell.CommandTaskComposeError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CommandTaskComposeError</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.tasks.shell.ShellTaskExecuteError" title="flowsaber.tasks.shell.ShellTaskExecuteError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ShellTaskExecuteError</span></code></a></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="flowsaber.tasks.shell.CommandTask">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.tasks.shell.</code><code class="sig-name descname">CommandTask</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.tasks.shell.CommandTask" title="Permalink to this definition">¶</a></dt>
<dd><p>Task used for composing bash command based on outputs data of channels. Users need to implement the
command method.
Note that the _output Channel of this task simply emits composed bash command in str type, and this
bash command needs to be actually executed by ShellTask.</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.tasks.shell.CommandTask.command" title="flowsaber.tasks.shell.CommandTask.command"><code class="xref py py-obj docutils literal notranslate"><span class="pre">command</span></code></a>(*args, **kwargs)</p></td>
<td><p>Users need to implement this function to compose the final bash command.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.tasks.shell.CommandTask.run" title="flowsaber.tasks.shell.CommandTask.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code></a>(*args, **kwargs)</p></td>
<td><p>Users need to implement this function to compose the final bash command.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.tasks.shell.CommandTask.command">
<code class="sig-name descname">command</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#flowsaber.tasks.shell.CommandTask.command" title="Permalink to this definition">¶</a></dt>
<dd><p>Users need to implement this function to compose the final bash command.</p>
<blockquote>
<div><p>The returned value of this method represents the expected outputs after executing the
composed bash command in shell:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>None represents the output is stdout.</p></li>
<li><p>str variables represents glob syntax for files in the working directory.</p></li>
</ol>
</div></blockquote>
<dl>
<dt>To tell flowsaber what’s the composed bash command, users has two options:</dt><dd><p>1: Assign the composed command to a variable named CMD.
2: Write virtual fstring as the docstring of command method. All variables in the command method</p>
<blockquote>
<div><p>scoped can be used freely.</p>
</div></blockquote>
</dd>
</dl>
<p>Here are some examples:</p>
<blockquote>
<div><dl class="simple">
<dt>class A(CommandTask):</dt><dd><dl class="simple">
<dt>def command(self, fa, fasta):</dt><dd><p>“bwa map -t {self.context.cpu} {fa} {fasta} -o {bam_file}”
bam_file = “test.bam”
return bam_file</p>
</dd>
</dl>
</dd>
<dt>class B(CommandTask):</dt><dd><dl class="simple">
<dt>def command(self, file):</dt><dd><p>a = “xxxx”
b = ‘xxxx’
CMD = f”echo {a}</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>“</dt><dd><p>f”echo {b}</p>
</dd>
</dl>
<dl>
<dt>“</dt><dd><blockquote>
<div><blockquote>
<div><p>f”cat {file}”</p>
</div></blockquote>
<p># here implicitly returned a None, represents the _output of cmd is stdout</p>
</div></blockquote>
<p>args
kwargs</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="flowsaber.tasks.shell.CommandTask.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#flowsaber.tasks.shell.CommandTask.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Users need to implement this function to compose the final bash command.</p>
<blockquote>
<div><p>The returned value of this method represents the expected outputs after executing the
composed bash command in shell:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>None represents the output is stdout.</p></li>
<li><p>str variables represents glob syntax for files in the working directory.</p></li>
</ol>
</div></blockquote>
<dl>
<dt>To tell flowsaber what’s the composed bash command, users has two options:</dt><dd><p>1: Assign the composed command to a variable named CMD.
2: Write virtual fstring as the docstring of command method. All variables in the command method</p>
<blockquote>
<div><p>scoped can be used freely.</p>
</div></blockquote>
</dd>
</dl>
<p>Here are some examples:</p>
<blockquote>
<div><dl class="simple">
<dt>class A(CommandTask):</dt><dd><dl class="simple">
<dt>def command(self, fa, fasta):</dt><dd><p>“bwa map -t {self.context.cpu} {fa} {fasta} -o {bam_file}”
bam_file = “test.bam”
return bam_file</p>
</dd>
</dl>
</dd>
<dt>class B(CommandTask):</dt><dd><dl class="simple">
<dt>def command(self, file):</dt><dd><p>a = “xxxx”
b = ‘xxxx’
CMD = f”echo {a}</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>“</dt><dd><p>f”echo {b}</p>
</dd>
</dl>
<dl>
<dt>“</dt><dd><blockquote>
<div><blockquote>
<div><p>f”cat {file}”</p>
</div></blockquote>
<p># here implicitly returned a None, represents the _output of cmd is stdout</p>
</div></blockquote>
<p>args
kwargs</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="flowsaber.tasks.shell.CommandTaskComposeError">
<em class="property">exception </em><code class="sig-prename descclassname">flowsaber.tasks.shell.</code><code class="sig-name descname">CommandTaskComposeError</code><a class="headerlink" href="#flowsaber.tasks.shell.CommandTaskComposeError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="flowsaber.tasks.shell.ShellFlow">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.tasks.shell.</code><code class="sig-name descname">ShellFlow</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.tasks.shell.ShellFlow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="flowsaber.tasks.shell.ShellTask">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.tasks.shell.</code><code class="sig-name descname">ShellTask</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.tasks.shell.ShellTask" title="Permalink to this definition">¶</a></dt>
<dd><p>Task that execute bash command by using subprocess.</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.tasks.shell.ShellTask.execute_shell_command" title="flowsaber.tasks.shell.ShellTask.execute_shell_command"><code class="xref py py-obj docutils literal notranslate"><span class="pre">execute_shell_command</span></code></a>(cmd, run_workdir[, envs])</p></td>
<td><p>Run command in shell</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.tasks.shell.ShellTask.get_publish_dirs" title="flowsaber.tasks.shell.ShellTask.get_publish_dirs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_publish_dirs</span></code></a>(flow_workdir, …)</p></td>
<td><p>Get absolute path of configured publish dirs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.tasks.shell.ShellTask.glob_output_files" title="flowsaber.tasks.shell.ShellTask.glob_output_files"><code class="xref py py-obj docutils literal notranslate"><span class="pre">glob_output_files</span></code></a>(item, run_workdir, …)</p></td>
<td><p>Iterate over the item hierarchically and convert in-place and glob found str into Files and collect them into the third parameter.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.tasks.shell.ShellTask.run" title="flowsaber.tasks.shell.ShellTask.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code></a>(cmd[, output, envs])</p></td>
<td><p>This method should be thread safe, can not run functions depends one process-base attributes like ENV, ….</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.tasks.shell.ShellTask.execute_shell_command">
<code class="sig-name descname">execute_shell_command</code><span class="sig-paren">(</span><em class="sig-param">cmd: str, run_workdir: Union[str, pathlib.Path], envs: dict = None</em><span class="sig-paren">)</span> &#x2192; Tuple[pathlib.Path, pathlib.Path]<a class="headerlink" href="#flowsaber.tasks.shell.ShellTask.execute_shell_command" title="Permalink to this definition">¶</a></dt>
<dd><p>Run command in shell</p>
<p>cmd
run_workdir
envs</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.tasks.shell.ShellTask.get_publish_dirs">
<em class="property">static </em><code class="sig-name descname">get_publish_dirs</code><span class="sig-paren">(</span><em class="sig-param">flow_workdir, configured_publish_dirs: List[str]</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.tasks.shell.ShellTask.get_publish_dirs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get absolute path of configured publish dirs.</p>
<p>flow_workdir
configured_publish_dirs</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.tasks.shell.ShellTask.glob_output_files">
<em class="property">classmethod </em><code class="sig-name descname">glob_output_files</code><span class="sig-paren">(</span><em class="sig-param">item, run_workdir, collect_files: List[flowsaber.core.utility.target.File]</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.tasks.shell.ShellTask.glob_output_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the item hierarchically and convert in-place and glob found str into Files
and collect them into the third parameter.</p>
<p>item
run_workdir
collect_files</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.tasks.shell.ShellTask.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">cmd: str</em>, <em class="sig-param">output=None</em>, <em class="sig-param">envs: dict = None</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.tasks.shell.ShellTask.run" title="Permalink to this definition">¶</a></dt>
<dd><p>This method should be thread safe, can not run functions depends one process-base attributes like ENV, ….</p>
<p>cmd
output
envs: dict</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="flowsaber.tasks.shell.ShellTaskExecuteError">
<em class="property">exception </em><code class="sig-prename descclassname">flowsaber.tasks.shell.</code><code class="sig-name descname">ShellTaskExecuteError</code><a class="headerlink" href="#flowsaber.tasks.shell.ShellTaskExecuteError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-flowsaber.core.flow">
<span id="flow"></span><h2>flow<a class="headerlink" href="#module-flowsaber.core.flow" title="Permalink to this headline">¶</a></h2>
<p><strong>Classes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Flow</span></code>(**kwargs)</p></td>
<td><p>Represents the organizer of tasks, flows can also be used as components.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="flowsaber.core.flow.Flow">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.flow.</code><code class="sig-name descname">Flow</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.flow.Flow" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents the organizer of tasks, flows can also be used as components. Except for the top-most flow
which represents the whole running unit, all flows within are simply virtual flows and don’t have running state
like flowrun or taskrun. However, flows and tasks all can have personalized configs.</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">call_initialize</span></code>(*args, **kwargs)</p></td>
<td><p>Copy a new one and initialize some attributes.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_context</span></code>()</p></td>
<td><p>Expose some attributes of self.config into self.context.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">start_execute</span></code>(**kwargs)</p></td>
<td><p>The up most flow needd to initialize executors.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.flow.Flow.call_initialize">
<code class="sig-name descname">call_initialize</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.flow.Flow.call_initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a new one and initialize some attributes.
Parameters
———-
args
kwargs</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.flow.Flow.initialize_context">
<code class="sig-name descname">initialize_context</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.flow.Flow.initialize_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Expose some attributes of self.config into self.context.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.flow.Flow.start_execute">
<em class="property">async </em><code class="sig-name descname">start_execute</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.flow.Flow.start_execute" title="Permalink to this definition">¶</a></dt>
<dd><p>The up most flow needd to initialize executors.
Parameters
———-
kwargs</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-flowsaber.core.base">
<span id="base"></span><h2>base<a class="headerlink" href="#module-flowsaber.core.base" title="Permalink to this headline">¶</a></h2>
<p><strong>Classes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Component</span></code>(**kwargs)</p></td>
<td><p>Base class of Flow and Task</p></td>
</tr>
</tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ComponentCallError</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ComponentExecuteError</span></code>(*args[, futures])</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<p><strong>Functions:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">aenter_context</span></code>(method)</p></td>
<td><p>A decorator runs the wrapped method within a new context composed of self.context and kwargs’ context.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">enter_context</span></code>(method)</p></td>
<td><p>A decorator runs the wrapped method within a new context composed of self.context and kwargs’ context.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="flowsaber.core.base.Component">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.base.</code><code class="sig-name descname">Component</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.base.Component" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class of Flow and Task</p>
<p><strong>Classes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">State</span></code></p></td>
<td><p>An enumeration.</p></td>
</tr>
</tbody>
</table>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">call_initialize</span></code>(*args, **kwargs)</p></td>
<td><p>Copy a new one and initialize some attributes.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_full_name</span></code>()</p></td>
<td><p>Generate a name like flow1.name|flow2.name|flow3.name|cur_task</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_context</span></code>()</p></td>
<td><p>Called by call_initialize, merge and update self.config dict of self.context from different sources.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">start</span></code>(**kwargs)</p></td>
<td><p>Start running the Flow/Task in the context of self.context, before setting the context, self.context will be merged/updated from kwargs.get(‘context’, {}) Parameters ———- kwargs</p></td>
</tr>
</tbody>
</table>
<p><strong>Attributes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">config</span></code></p></td>
<td><p>return a non-editable context</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="flowsaber.core.base.Component.State">
<em class="property">class </em><code class="sig-name descname">State</code><a class="headerlink" href="#flowsaber.core.base.Component.State" title="Permalink to this definition">¶</a></dt>
<dd><p>An enumeration.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.base.Component.call_initialize">
<code class="sig-name descname">call_initialize</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.base.Component.call_initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a new one and initialize some attributes.
Parameters
———-
args
kwargs</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.base.Component.config">
<em class="property">property </em><code class="sig-name descname">config</code><a class="headerlink" href="#flowsaber.core.base.Component.config" title="Permalink to this definition">¶</a></dt>
<dd><p>return a non-editable context</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.base.Component.get_full_name">
<code class="sig-name descname">get_full_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#flowsaber.core.base.Component.get_full_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a name like flow1.name|flow2.name|flow3.name|cur_task</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.base.Component.initialize_context">
<code class="sig-name descname">initialize_context</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.base.Component.initialize_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by call_initialize, merge and update self.config dict of self.context from different sources.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.base.Component.start">
<em class="property">async </em><code class="sig-name descname">start</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.base.Component.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start running the Flow/Task in the context of self.context, before setting the context,
self.context will be merged/updated from kwargs.get(‘context’, {})
Parameters
———-
kwargs</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="flowsaber.core.base.ComponentCallError">
<em class="property">exception </em><code class="sig-prename descclassname">flowsaber.core.base.</code><code class="sig-name descname">ComponentCallError</code><a class="headerlink" href="#flowsaber.core.base.ComponentCallError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="exception">
<dt id="flowsaber.core.base.ComponentExecuteError">
<em class="property">exception </em><code class="sig-prename descclassname">flowsaber.core.base.</code><code class="sig-name descname">ComponentExecuteError</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">futures=None</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.base.ComponentExecuteError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="flowsaber.core.base.aenter_context">
<code class="sig-prename descclassname">flowsaber.core.base.</code><code class="sig-name descname">aenter_context</code><span class="sig-paren">(</span><em class="sig-param">method: Callable[[...], Any]</em><span class="sig-paren">)</span> &#x2192; Any<a class="headerlink" href="#flowsaber.core.base.aenter_context" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator runs the wrapped method within a new context composed of self.context and kwargs’ context.</p>
<p>method</p>
</dd></dl>

<dl class="function">
<dt id="flowsaber.core.base.enter_context">
<code class="sig-prename descclassname">flowsaber.core.base.</code><code class="sig-name descname">enter_context</code><span class="sig-paren">(</span><em class="sig-param">method: Callable[[...], Any]</em><span class="sig-paren">)</span> &#x2192; Any<a class="headerlink" href="#flowsaber.core.base.enter_context" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator runs the wrapped method within a new context composed of self.context and kwargs’ context.</p>
<p>method</p>
</dd></dl>

</div>
<div class="section" id="module-flowsaber.core.context">
<span id="context"></span><h2>context<a class="headerlink" href="#module-flowsaber.core.context" title="Permalink to this headline">¶</a></h2>
<p>During the running of flow, flowsaber.context will automatically be updated, Ideally, at the end of a task run,
context will be looked like this:</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a>`
flow_config: {}
task_config: {}</p>
<p>flow_id
flow_name
flow_full_name
flow_labels</p>
<p>task_id
task_name
task_full_name
task_labels</p>
<p>id
flowrun_name</p>
<p>taskrun_id
<a href="#id3"><span class="problematic" id="id4">``</span></a><a href="#id5"><span class="problematic" id="id6">`</span></a></p>
<p><strong>Classes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.context.FlowSaberContext" title="flowsaber.core.context.FlowSaberContext"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FlowSaberContext</span></code></a>(*args, **kwargs)</p></td>
<td><p>The global coroutine-safe context meant to be used for inferring the running status of a flow at any time.</p></td>
</tr>
</tbody>
</table>
<p><strong>Functions:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.context.inject_context_attrs" title="flowsaber.core.context.inject_context_attrs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inject_context_attrs</span></code></a>(factory)</p></td>
<td><p>Inject context attrs into the log record base on context.context_attrs.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="flowsaber.core.context.FlowSaberContext">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.context.</code><code class="sig-name descname">FlowSaberContext</code><span class="sig-paren">(</span><em class="sig-param">*args: Any</em>, <em class="sig-param">**kwargs: Any</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.context.FlowSaberContext" title="Permalink to this definition">¶</a></dt>
<dd><p>The global coroutine-safe context meant to be used for inferring the running status of a flow at any time.
Compared to raw context, this global context has intelligent(automatically change according to the
time/position of the callee) properties:</p>
<blockquote>
<div><p>cache: used by running flow/task
run_lock: used by running task
logger: used in anywhere and anytime
executor: used by running task</p>
</div></blockquote>
<p><strong>Attributes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.context.FlowSaberContext.cache" title="flowsaber.core.context.FlowSaberContext.cache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache</span></code></a></p></td>
<td><p>Fetch a Cache based on <cite>cache_type</cite> in the current context.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.context.FlowSaberContext.executor" title="flowsaber.core.context.FlowSaberContext.executor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">executor</span></code></a></p></td>
<td><p>Fetch an initialized executor based on <cite>executor_type</cite> in the current context.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.context.FlowSaberContext.logger" title="flowsaber.core.context.FlowSaberContext.logger"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logger</span></code></a></p></td>
<td><p>Get a child logger of <cite>flowsaber</cite> logger with name of: <cite>callee.__name__.agent_id.flow_id.id.task_id.taskrun_id</cite></p></td>
</tr>
</tbody>
</table>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.context.FlowSaberContext.lock" title="flowsaber.core.context.FlowSaberContext.lock"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lock</span></code></a>(keys)</p></td>
<td><p>Fetch a asyncio.Lock based on <cite>run_workdir</cite> in the current context.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.context.FlowSaberContext.cache">
<em class="property">property </em><code class="sig-name descname">cache</code><a class="headerlink" href="#flowsaber.core.context.FlowSaberContext.cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch a Cache based on <cite>cache_type</cite> in the current context.
Returns
——-</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.context.FlowSaberContext.executor">
<em class="property">property </em><code class="sig-name descname">executor</code><a class="headerlink" href="#flowsaber.core.context.FlowSaberContext.executor" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch an initialized executor based on <cite>executor_type</cite> in the current context.
Returns
——-</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.context.FlowSaberContext.lock">
<code class="sig-name descname">lock</code><span class="sig-paren">(</span><em class="sig-param">keys: List[str]</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.context.FlowSaberContext.lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch a asyncio.Lock based on <cite>run_workdir</cite> in the current context.
Returns
——-</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.context.FlowSaberContext.logger">
<em class="property">property </em><code class="sig-name descname">logger</code><a class="headerlink" href="#flowsaber.core.context.FlowSaberContext.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a child logger of <cite>flowsaber</cite> logger with name of:
<cite>callee.__name__.agent_id.flow_id.id.task_id.taskrun_id</cite></p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="flowsaber.core.context.inject_context_attrs">
<code class="sig-prename descclassname">flowsaber.core.context.</code><code class="sig-name descname">inject_context_attrs</code><span class="sig-paren">(</span><em class="sig-param">factory</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.context.inject_context_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Inject context attrs into the log record base on context.context_attrs.
Parameters
———-
factory</p>
</dd></dl>

</div>
<div class="section" id="module-flowsaber.core.channel">
<span id="channel"></span><h2>channel<a class="headerlink" href="#module-flowsaber.core.channel" title="Permalink to this headline">¶</a></h2>
<p><strong>Classes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Channel</span></code>([queue_factory])</p></td>
<td><p>Subclass of ChannelBase implemented create_queue method, the mechanism for sending data to all created queue is simple, it just loop over all queues and push the item specified by call of put/put_nowait into all queues.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ChannelBase</span></code>(**kwargs)</p></td>
<td><p>A channel it self is an object for storing items by using put/put_nowait.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstantChannel</span></code>(**kwargs)</p></td>
<td><p>A channel use ConstantQueue as it’s fetcher queue factory.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstantQueue</span></code>()</p></td>
<td><p>A async queue will emit it’s internal value infinitely.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Consumer</span></code>(*queues, **kwargs)</p></td>
<td><p>Consumer is an object used for simultaneously fetching data emitted by multiple channels and output tuples.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Fetcher</span></code>(**kwargs)</p></td>
<td><p>Fetch simple provide a for/async for method support for classes implemented with get/get_nowait methods.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">LazyAsyncQueue</span></code>(ch, queue_factory, **kwargs)</p></td>
<td><p>Internally it’s an asyncio.Queue, but the inner queue will only be created when meets the first call it’s fetcher/putter methods.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="flowsaber.core.channel.Channel">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.channel.</code><code class="sig-name descname">Channel</code><span class="sig-paren">(</span><em class="sig-param">queue_factory: type = &lt;class 'asyncio.queues.Queue'&gt;</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.channel.Channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Subclass of ChannelBase implemented create_queue method, the mechanism for sending data to all created queue is
simple, it just loop over all queues and push the item specified by call of put/put_nowait into all queues.
Furthermore, to make LazyAsyncQueue initialized only in a running event loop, Channel uses a buffer to buffer all
items pushed before entering the event loop.</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.channel.ChannelBase">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.channel.</code><code class="sig-name descname">ChannelBase</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.channel.ChannelBase" title="Permalink to this definition">¶</a></dt>
<dd><p>A channel it self is an object for storing items by using put/put_nowait. To consume data from the channel,
users must call ChannelBase.create_queue method to get a fetcher LazyAsyncQueue, and then call it’s get/get_nowait method
to fetched the data emitted by the channel.</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">branch</span></code>(*args, num, by, **kwargs)</p></td>
<td><p>Dispatch _input into specified number of channels base on the returned index of the predicate function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">collect</span></code>(*args[, num_out])</p></td>
<td><p>Opposite to flatten, turns a channel into a tuple</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">concat</span></code>(*args[, num_out])</p></td>
<td><p>Data in channels are concatenated in the order of _input channels.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">distinct</span></code>(*args, **kwargs)</p></td>
<td><p>Remove continuously duplicated item.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">filter</span></code>(*args[, by])</p></td>
<td><p>Filter item by the predicate function or the comparing identity.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">first</span></code>(*args, **kwargs)</p></td>
<td><p>Take the first item</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">flatten</span></code>(*args[, max_level])</p></td>
<td><p>Flatten the _output of channel.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_list</span></code>([1, 2, 3, 4, 5])</p></td>
<td><p>QueueChannel created by this method will always include a END signal</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">getitem</span></code>(*args, key, **kwargs)</p></td>
<td><p>Get item from the output of the input channel with specified key, like <cite>obj[key]</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">group</span></code>(*args[, by, num, keep])</p></td>
<td><p>return a new channel with item of Tuple(key_fn(_input), grouped_data_tuple), the group size can be specified.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">last</span></code>(*args, **kwargs)</p></td>
<td><p>Take the last item</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">map</span></code>(*args, by, **kwargs)</p></td>
<td><p>Map each item to another item return by the specified map function into a new channel.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge</span></code>(*args[, num_out])</p></td>
<td><p>Merge channels into a channel with _output of tuple.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mix</span></code>(*args[, num_out])</p></td>
<td><p>Data emitted bu channels are mixed into a single channel.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduce</span></code>(*args, by[, result])</p></td>
<td><p>Similar to normal reduce.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample</span></code>(*args[, num])</p></td>
<td><p>Randomly sample at most <cite>num</cite> number of _input emitted by the channel using reservoir algorithm(should visit all elements.).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">select</span></code>(*args, key, **kwargs)</p></td>
<td><p>Alias for GetItem task.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(*args, num, **kwargs)</p></td>
<td><p>Used when _output is tuple/list, use split to split each item of the tuple into a unique channel.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">subscribe</span></code>(*args[, on_next, on_complete])</p></td>
<td><p>specify on_next or on_complete function as callbacks of these two event.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code>(*args[, num])</p></td>
<td><p>Only take the first <cite>num</cite> number of items</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique</span></code>(*args, **kwargs)</p></td>
<td><p>Emit items at most once(no duplicate).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">until</span></code>(*args, by, **kwargs)</p></td>
<td><p>“Take items until meet a stop marker.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">value</span></code>(value, **kwargs)</p></td>
<td><p>Channel._output(1)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code>(1, 2, 3, 4, 5)</p></td>
<td><p>QueueChannel created by this method will always include a END signal</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">view</span></code>(*args, **kwargs)</p></td>
<td><p>Print each item emitted by the channel, Equals to call Subscribe(on_next=print)</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.branch">
<code class="sig-name descname">branch</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], num: int, by: Callable, **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.branch" title="Permalink to this definition">¶</a></dt>
<dd><p>Dispatch _input into specified number of channels base on the returned index of the predicate function.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.collect">
<code class="sig-name descname">collect</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], num_out: int = 1, **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.collect" title="Permalink to this definition">¶</a></dt>
<dd><p>Opposite to flatten, turns a channel into a tuple</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.concat">
<code class="sig-name descname">concat</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], num_out: int = 1, **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Data in channels are concatenated in the order of _input channels.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.distinct">
<code class="sig-name descname">distinct</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.distinct" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove continuously duplicated item.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.filter">
<code class="sig-name descname">filter</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], by: Union[Callable[[Any], bool], object] = &lt;function Filter.&lt;lambda&gt;&gt;, **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter item by the predicate function or the comparing identity.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.first">
<code class="sig-name descname">first</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.first" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the first item</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.flatten">
<code class="sig-name descname">flatten</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], max_level: int = None, **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Flatten the _output of channel.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.from_list">
<em class="property">classmethod </em><code class="sig-name descname">from_list</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">1</em>, <em class="sig-param">2</em>, <em class="sig-param">3</em>, <em class="sig-param">4</em>, <em class="sig-param">5</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.channel.ChannelBase.from_list" title="Permalink to this definition">¶</a></dt>
<dd><p>QueueChannel created by this method will always include a END signal</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.getitem">
<code class="sig-name descname">getitem</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], key: Any, **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.getitem" title="Permalink to this definition">¶</a></dt>
<dd><p>Get item from the output of the input channel with specified key, like <cite>obj[key]</cite>. The input channel is excepted
to emit objects with <cite>__getitem__</cite> method. For example, tuple, list, dict ….</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.group">
<code class="sig-name descname">group</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], by: Callable = &lt;function Group.&lt;lambda&gt;&gt;, num: int = inf, keep: bool = True, **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.group" title="Permalink to this definition">¶</a></dt>
<dd><p>return a new channel with item of Tuple(key_fn(_input), grouped_data_tuple),
the group size can be specified.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.last">
<code class="sig-name descname">last</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.last" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the last item</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.map">
<code class="sig-name descname">map</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], by: Callable, **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Map each item to another item return by the specified map function into a new channel.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.merge">
<code class="sig-name descname">merge</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], num_out: int = 1, **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge channels into a channel with _output of tuple.
Even if there is only one channel _input, always _output a tuple</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.mix">
<code class="sig-name descname">mix</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], num_out: int = 1, **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.mix" title="Permalink to this definition">¶</a></dt>
<dd><p>Data emitted bu channels are mixed into a single channel.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.reduce">
<code class="sig-name descname">reduce</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], by: Callable[[Any, Any], Any], result=&lt;object object&gt;, **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to normal reduce. results = f(n, f(n - 1))</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], num: int = 1, **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly sample at most <cite>num</cite> number of _input emitted by the channel
using reservoir algorithm(should visit all elements.).</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.select">
<code class="sig-name descname">select</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], key: Any, **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for GetItem task.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.split">
<code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], num: int, **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Used when _output is tuple/list, use split to split each item of the tuple into a unique channel.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.subscribe">
<code class="sig-name descname">subscribe</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], on_next: Callable = None, on_complete: Callable = None, **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.subscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>specify on_next or on_complete function as callbacks of these two event.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.take">
<code class="sig-name descname">take</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], num: int = 1, **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Only take the first <cite>num</cite> number of items</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.unique">
<code class="sig-name descname">unique</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Emit items at most once(no duplicate).</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.until">
<code class="sig-name descname">until</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], by: Union[Callable[[Any], bool], object], **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.until" title="Permalink to this definition">¶</a></dt>
<dd><p>“Take items until meet a stop marker. the stop item will not be included</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.value">
<em class="property">classmethod </em><code class="sig-name descname">value</code><span class="sig-paren">(</span><em class="sig-param">value</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span> &#x2192; flowsaber.core.channel.ConstantChannel<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Channel._output(1)</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.values">
<em class="property">classmethod </em><code class="sig-name descname">values</code><span class="sig-paren">(</span><em class="sig-param">1</em>, <em class="sig-param">2</em>, <em class="sig-param">3</em>, <em class="sig-param">4</em>, <em class="sig-param">5</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.channel.ChannelBase.values" title="Permalink to this definition">¶</a></dt>
<dd><p>QueueChannel created by this method will always include a END signal</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.channel.ChannelBase.view">
<code class="sig-name descname">view</code><span class="sig-paren">(</span><em class="sig-param">*args: Union[object, flowsaber.core.channel.Channel], **kwargs</em><span class="sig-paren">)</span> &#x2192; Union[Sequence[flowsaber.core.channel.Channel], flowsaber.core.channel.Channel]<a class="headerlink" href="#flowsaber.core.channel.ChannelBase.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Print each item emitted by the channel, Equals to call Subscribe(on_next=print)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.channel.ConstantChannel">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.channel.</code><code class="sig-name descname">ConstantChannel</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.channel.ConstantChannel" title="Permalink to this definition">¶</a></dt>
<dd><p>A channel use ConstantQueue as it’s fetcher queue factory.</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.channel.ConstantQueue">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.channel.</code><code class="sig-name descname">ConstantQueue</code><a class="headerlink" href="#flowsaber.core.channel.ConstantQueue" title="Permalink to this definition">¶</a></dt>
<dd><p>A async queue will emit it’s internal value infinitely. Like ordinary queue, the first element
needs to be enqueued before fetching</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.channel.Consumer">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.channel.</code><code class="sig-name descname">Consumer</code><span class="sig-paren">(</span><em class="sig-param">*queues: flowsaber.core.channel.LazyAsyncQueue</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.channel.Consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>Consumer is an object used for simultaneously fetching data emitted by multiple channels and output tuples.
Empty consumer will emit only once. The end of __next__/__anext__ will be triggered if any of it’s source channel
emits a END object. For simplicity, if there is only a single source channel, the output of consumer will not be
a tuple.</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.channel.Fetcher">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.channel.</code><code class="sig-name descname">Fetcher</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.channel.Fetcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch simple provide a for/async for method support for classes implemented with get/get_nowait methods.
The end of __next__/__anext__ is triggered by the appearance of END fetched from get/get_nowait.</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.channel.LazyAsyncQueue">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.channel.</code><code class="sig-name descname">LazyAsyncQueue</code><span class="sig-paren">(</span><em class="sig-param">ch</em>, <em class="sig-param">queue_factory</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.channel.LazyAsyncQueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Internally it’s an asyncio.Queue, but the inner queue will only be created when meets the first call
it’s fetcher/putter methods. It’s designed like this to handler pickle or coroutine-loop problems.</p>
</dd></dl>

</div>
<div class="section" id="module-flowsaber.core.utility.state">
<span id="state"></span><h2>state<a class="headerlink" href="#module-flowsaber.core.utility.state" title="Permalink to this headline">¶</a></h2>
<p><strong>Classes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.utility.state.Cached" title="flowsaber.core.utility.state.Cached"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cached</span></code></a>([state_type, result, message])</p></td>
<td><p>The result of the _input is cached.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.utility.state.Cancelled" title="flowsaber.core.utility.state.Cancelled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cancelled</span></code></a>([trace_back])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.utility.state.Cancelling" title="flowsaber.core.utility.state.Cancelling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cancelling</span></code></a>([state_type, result, message])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.utility.state.Done" title="flowsaber.core.utility.state.Done"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Done</span></code></a>([state_type, result, message])</p></td>
<td><p>Represent the end state of a task run, should not be directly used.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.utility.state.Drop" title="flowsaber.core.utility.state.Drop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Drop</span></code></a>([state_type, result, message])</p></td>
<td><p>This state means the _output should be dropped and will not be passed to the _output channel.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.utility.state.Failure" title="flowsaber.core.utility.state.Failure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Failure</span></code></a>([trace_back])</p></td>
<td><p>Means some Exception has been raised.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.utility.state.Pending" title="flowsaber.core.utility.state.Pending"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Pending</span></code></a>([state_type, result, message])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.utility.state.Retrying" title="flowsaber.core.utility.state.Retrying"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Retrying</span></code></a>([state_type, result, message])</p></td>
<td><p>This state comes from Pending, means the task is waiting for rerun due to retry’s waiting time</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.utility.state.Running" title="flowsaber.core.utility.state.Running"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Running</span></code></a>([state_type, result, message])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.utility.state.Scheduled" title="flowsaber.core.utility.state.Scheduled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Scheduled</span></code></a>([state_type, result, message])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.utility.state.Skip" title="flowsaber.core.utility.state.Skip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Skip</span></code></a>([state_type, result, message])</p></td>
<td><p>This state means this _output should be skipped and directly send to the _output channel</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#flowsaber.core.utility.state.State" title="flowsaber.core.utility.state.State"><code class="xref py py-obj docutils literal notranslate"><span class="pre">State</span></code></a>([state_type, result, message])</p></td>
<td><p>State represents status of flowrun/taskrun.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#flowsaber.core.utility.state.Success" title="flowsaber.core.utility.state.Success"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Success</span></code></a>([state_type, result, message])</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="flowsaber.core.utility.state.Cached">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.state.</code><code class="sig-name descname">Cached</code><span class="sig-paren">(</span><em class="sig-param">state_type: str = None</em>, <em class="sig-param">result: Any = None</em>, <em class="sig-param">message: str = None</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.state.Cached" title="Permalink to this definition">¶</a></dt>
<dd><p>The result of the _input is cached.</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.state.Cancelled">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.state.</code><code class="sig-name descname">Cancelled</code><span class="sig-paren">(</span><em class="sig-param">trace_back=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.state.Cancelled" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.state.Cancelling">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.state.</code><code class="sig-name descname">Cancelling</code><span class="sig-paren">(</span><em class="sig-param">state_type: str = None</em>, <em class="sig-param">result: Any = None</em>, <em class="sig-param">message: str = None</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.state.Cancelling" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.state.Done">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.state.</code><code class="sig-name descname">Done</code><span class="sig-paren">(</span><em class="sig-param">state_type: str = None</em>, <em class="sig-param">result: Any = None</em>, <em class="sig-param">message: str = None</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.state.Done" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent the end state of a task run, should not be directly used. Use Success/Failure instead.</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.state.Drop">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.state.</code><code class="sig-name descname">Drop</code><span class="sig-paren">(</span><em class="sig-param">state_type: str = None</em>, <em class="sig-param">result: Any = None</em>, <em class="sig-param">message: str = None</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.state.Drop" title="Permalink to this definition">¶</a></dt>
<dd><p>This state means the _output should be dropped and will not be passed to the _output channel.
Usually this is caused by settled skip on error option in task.config_dict</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.state.Failure">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.state.</code><code class="sig-name descname">Failure</code><span class="sig-paren">(</span><em class="sig-param">trace_back=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.state.Failure" title="Permalink to this definition">¶</a></dt>
<dd><p>Means some Exception has been raised.</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.state.Pending">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.state.</code><code class="sig-name descname">Pending</code><span class="sig-paren">(</span><em class="sig-param">state_type: str = None</em>, <em class="sig-param">result: Any = None</em>, <em class="sig-param">message: str = None</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.state.Pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.state.Retrying">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.state.</code><code class="sig-name descname">Retrying</code><span class="sig-paren">(</span><em class="sig-param">state_type: str = None</em>, <em class="sig-param">result: Any = None</em>, <em class="sig-param">message: str = None</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.state.Retrying" title="Permalink to this definition">¶</a></dt>
<dd><p>This state comes from Pending, means the task is waiting for rerun due to retry’s waiting time</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.state.Running">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.state.</code><code class="sig-name descname">Running</code><span class="sig-paren">(</span><em class="sig-param">state_type: str = None</em>, <em class="sig-param">result: Any = None</em>, <em class="sig-param">message: str = None</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.state.Running" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.state.Scheduled">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.state.</code><code class="sig-name descname">Scheduled</code><span class="sig-paren">(</span><em class="sig-param">state_type: str = None</em>, <em class="sig-param">result: Any = None</em>, <em class="sig-param">message: str = None</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.state.Scheduled" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.state.Skip">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.state.</code><code class="sig-name descname">Skip</code><span class="sig-paren">(</span><em class="sig-param">state_type: str = None</em>, <em class="sig-param">result: Any = None</em>, <em class="sig-param">message: str = None</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.state.Skip" title="Permalink to this definition">¶</a></dt>
<dd><p>This state means this _output should be skipped and directly send to the _output channel</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.state.State">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.state.</code><code class="sig-name descname">State</code><span class="sig-paren">(</span><em class="sig-param">state_type: str = None</em>, <em class="sig-param">result: Any = None</em>, <em class="sig-param">message: str = None</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.state.State" title="Permalink to this definition">¶</a></dt>
<dd><p>State represents status of flowrun/taskrun.</p>
<p>State flows and state hierarchy:</p>
<blockquote>
<div><dl class="simple">
<dt>FlowRun:</dt><dd><p>Scheduled Pending Running Done</p>
</dd>
<dt>TaskRun:</dt><dd><p>Pending Running Retrying Running Done</p>
</dd>
<dt>Done</dt><dd><dl class="simple">
<dt>Success</dt><dd><p>Cached
Skip</p>
</dd>
<dt>Failure</dt><dd><p>Drop</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.state.Success">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.state.</code><code class="sig-name descname">Success</code><span class="sig-paren">(</span><em class="sig-param">state_type: str = None</em>, <em class="sig-param">result: Any = None</em>, <em class="sig-param">message: str = None</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.state.Success" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-flowsaber.core.utility.cache">
<span id="cache"></span><h2>cache<a class="headerlink" href="#module-flowsaber.core.utility.cache" title="Permalink to this headline">¶</a></h2>
<p><strong>Classes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cache</span></code></p></td>
<td><p>Cache is used for persisting results of met inputs.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">LocalCache</span></code>([serializer])</p></td>
<td><p>LocalCache treat hash keys as directories in disk and dump/load python objects in the corresponding directories.</p></td>
</tr>
</tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">CacheInvalidError</span></code></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="flowsaber.core.utility.cache.Cache">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.cache.</code><code class="sig-name descname">Cache</code><a class="headerlink" href="#flowsaber.core.utility.cache.Cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Cache is used for persisting results of met inputs. The cache should produce unique keys for unique inputs by
implementing <cite>hash</cite> method. Hash of inputs can be further used to write/read related data.</p>
</dd></dl>

<dl class="exception">
<dt id="flowsaber.core.utility.cache.CacheInvalidError">
<em class="property">exception </em><code class="sig-prename descclassname">flowsaber.core.utility.cache.</code><code class="sig-name descname">CacheInvalidError</code><a class="headerlink" href="#flowsaber.core.utility.cache.CacheInvalidError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.cache.LocalCache">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.cache.</code><code class="sig-name descname">LocalCache</code><span class="sig-paren">(</span><em class="sig-param">serializer: flowsaber.core.utility.cache.Serializer = &lt;flowsaber.core.utility.cache.CloudPickleSerializer object&gt;</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.cache.LocalCache" title="Permalink to this definition">¶</a></dt>
<dd><p>LocalCache treat hash keys as directories in disk and dump/load python objects in the corresponding directories.</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">persist</span></code>()</p></td>
<td><p>This should be called before python program ends</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.utility.cache.LocalCache.persist">
<code class="sig-name descname">persist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.cache.LocalCache.persist" title="Permalink to this definition">¶</a></dt>
<dd><p>This should be called before python program ends</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-flowsaber.core.utility.target">
<span id="target"></span><h2>target<a class="headerlink" href="#module-flowsaber.core.utility.target" title="Permalink to this headline">¶</a></h2>
<p><strong>Classes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">End</span></code>(**kwargs)</p></td>
<td><p>End signal of a Channel.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">File</span></code>(*args, **kwargs)</p></td>
<td><p>Wrapping of <cite>pathlib.Path</cite>, with features including integrity checking …</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Stdin</span></code>(src, **kwargs)</p></td>
<td><p>Represents stdin from a string or File.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Stdout</span></code>(*args, **kwargs)</p></td>
<td><p>Ugly way, Use File to store stdout.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Target</span></code>(**kwargs)</p></td>
<td><p>Target represents item emitted by Channel.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="flowsaber.core.utility.target.End">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.target.</code><code class="sig-name descname">End</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.target.End" title="Permalink to this definition">¶</a></dt>
<dd><p>End signal of a Channel.</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.target.File">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.target.</code><code class="sig-name descname">File</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.target.File" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapping of <cite>pathlib.Path</cite>, with features including integrity checking …</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.target.Stdin">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.target.</code><code class="sig-name descname">Stdin</code><span class="sig-paren">(</span><em class="sig-param">src: Union[str, flowsaber.core.utility.target.File], **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.target.Stdin" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents stdin from a string or File.</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.target.Stdout">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.target.</code><code class="sig-name descname">Stdout</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.target.Stdout" title="Permalink to this definition">¶</a></dt>
<dd><p>Ugly way, Use File to store stdout.
In the idealist implementation, stdout and stdin can be piped/linked across machines over network.</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.target.Target">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.target.</code><code class="sig-name descname">Target</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.target.Target" title="Permalink to this definition">¶</a></dt>
<dd><p>Target represents item emitted by Channel. Theoretically all item emitted by Channel should be wrapped by a Target</p>
</dd></dl>

</div>
<div class="section" id="module-flowsaber.core.utility.executor">
<span id="executor"></span><h2>executor<a class="headerlink" href="#module-flowsaber.core.utility.executor" title="Permalink to this headline">¶</a></h2>
<p>Borrowed from prefect.executors.dask</p>
<p><strong>Classes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">DaskExecutor</span></code>([address, cluster_class, …])</p></td>
<td><p>An executor that runs all functions using the <cite>dask.distributed</cite> scheduler.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Executor</span></code>(**kwargs)</p></td>
<td><p>Async Executor is aimed for running submitted jobs in an asynchronous way.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Local</span></code>(**kwargs)</p></td>
<td><p>Executor run jobs in the main loop of the current thread,</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="flowsaber.core.utility.executor.DaskExecutor">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.executor.</code><code class="sig-name descname">DaskExecutor</code><span class="sig-paren">(</span><em class="sig-param">address: str = None</em>, <em class="sig-param">cluster_class: Union[str</em>, <em class="sig-param">Callable] = None</em>, <em class="sig-param">cluster_kwargs: dict = None</em>, <em class="sig-param">adapt_kwargs: dict = None</em>, <em class="sig-param">client_kwargs: dict = None</em>, <em class="sig-param">debug: bool = False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.executor.DaskExecutor" title="Permalink to this definition">¶</a></dt>
<dd><p>An executor that runs all functions using the <cite>dask.distributed</cite> scheduler.</p>
<p>Check <a class="reference external" href="https://docs.dask.org/en/latest/setup.html">https://docs.dask.org/en/latest/setup.html</a> for all kinds of cluster types.</p>
<p>By default a temporary <cite>distributed.LocalCluster</cite> is created (and
subsequently torn down) within the <cite>start_loop()</cite> contextmanager. To use a
different cluster class (e.g.
[<cite>dask_kubernetes.KubeCluster</cite>](<a class="reference external" href="https://kubernetes.dask.org/">https://kubernetes.dask.org/</a>)), you can
specify <cite>cluster_class</cite>/<cite>cluster_kwargs</cite>.</p>
<p>Alternatively, if you already have a dask cluster _running, you can provide
the address of the scheduler via the <cite>address</cite> kwarg.</p>
<p>Note that if you have tasks with tags of the form <cite>“dask-accum_resource:KEY=NUM”</cite>
they will be parsed and passed as
[Worker Resources](<a class="reference external" href="https://distributed.dask.org/en/latest/resources.html">https://distributed.dask.org/en/latest/resources.html</a>)
of the form <cite>{“KEY”: float(NUM)}</cite> to the Dask TaskScheduler.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>address (string, optional): address of a currently _running dask</dt><dd><p>scheduler; if one is not provided, a temporary cluster will be
created in <cite>executor.start_loop()</cite>.  Defaults to <cite>None</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>cluster_class (string or callable, optional): the cluster class to use</dt><dd><p>when creating a temporary dask cluster. Can be either the full
class name (e.g. <cite>“distributed.LocalCluster”</cite>), or the class itself.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>cluster_kwargs (dict, optional): addtional kwargs to pass to the</dt><dd><p><cite>cluster_class</cite> when creating a temporary dask cluster.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>adapt_kwargs (dict, optional): additional kwargs to pass to <cite>cluster.adapt</cite></dt><dd><p>when creating a temporary dask cluster. Note that adaptive scaling
is only enabled if <cite>adapt_kwargs</cite> are provided.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>client_kwargs (dict, optional): additional kwargs to use when creating a</dt><dd><p>[<cite>dask.distributed.Client</cite>](<a class="reference external" href="https://distributed.dask.org/en/latest/api.html#client">https://distributed.dask.org/en/latest/api.html#client</a>).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>debug (bool, optional): When _running with a local cluster, setting</dt><dd><p><cite>debug=True</cite> will increase dask’s logging level, providing
potentially useful debug info. Defaults to the <cite>debug</cite> value in
your Prefect configuration.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Examples:</p>
<p>Using a temporary local dask cluster:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">executor</span> <span class="pre">=</span> <span class="pre">DaskExecutor()</span>
<span class="pre">`</span></code></p>
<p>Using a temporary cluster _running elsewhere. Any Dask cluster class should
work, here we use [dask-cloudprovider](<a class="reference external" href="https://cloudprovider.dask.org">https://cloudprovider.dask.org</a>):</p>
<p><a href="#id7"><span class="problematic" id="id8">``</span></a><a href="#id9"><span class="problematic" id="id10">`</span></a>python
executor = DaskExecutor(</p>
<blockquote>
<div><p>cluster_class=”dask_cloudprovider.FargateCluster”,
cluster_kwargs={</p>
<blockquote>
<div><p>“image”: “prefecthq/prefect:latest”,
“n_workers”: 5,
…</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>Connecting to an existing dask cluster</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">executor</span> <span class="pre">=</span> <span class="pre">DaskExecutor(address=&quot;192.0.2.255:8786&quot;)</span>
<span class="pre">`</span></code></p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code>(fn, *args[, extra_context])</p></td>
<td><p>Submit a function to the executor for execution.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.utility.executor.DaskExecutor.run">
<em class="property">async </em><code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">fn: Callable</em>, <em class="sig-param">*args: Any</em>, <em class="sig-param">extra_context: dict = None</em>, <em class="sig-param">**kwargs: Any</em><span class="sig-paren">)</span> &#x2192; concurrent.futures._base.Future<a class="headerlink" href="#flowsaber.core.utility.executor.DaskExecutor.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Submit a function to the executor for execution. Returns a Future object.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>fn (Callable): function that is being submitted for execution</p></li>
<li><p><a href="#id11"><span class="problematic" id="id12">*</span></a>args (Any): arguments to be passed to <cite>fn</cite></p></li>
<li><dl class="simple">
<dt>extra_context (dict, optional): an optional dictionary with extra information</dt><dd><p>about the submitted task</p>
</dd>
</dl>
</li>
<li><p><a href="#id13"><span class="problematic" id="id14">**</span></a>kwargs (Any): keyword arguments to be passed to <cite>fn</cite></p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>Future: a Future-like object that represents the computation of <cite>fn(*args, **kwargs)</cite></p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.executor.Executor">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.executor.</code><code class="sig-name descname">Executor</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.executor.Executor" title="Permalink to this definition">¶</a></dt>
<dd><p>Async Executor is aimed for running submitted jobs in an asynchronous way. Executor need to implement three
__aenter__/__aexit__/run async functions for initializing/running/cleaning.</p>
</dd></dl>

<dl class="class">
<dt id="flowsaber.core.utility.executor.Local">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.utility.executor.</code><code class="sig-name descname">Local</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.utility.executor.Local" title="Permalink to this definition">¶</a></dt>
<dd><p>Executor run jobs in the main loop of the current thread,</p>
</dd></dl>

</div>
<div class="section" id="module-flowsaber.core.engine.runner">
<span id="runner"></span><h2>runner<a class="headerlink" href="#module-flowsaber.core.engine.runner" title="Permalink to this headline">¶</a></h2>
<p>Some codes are borrowed from <a class="reference external" href="https://github.com/PrefectHQ/prefect/blob/master/src/prefect/engine/runner.py">https://github.com/PrefectHQ/prefect/blob/master/src/prefect/engine/runner.py</a></p>
<p><strong>Exceptions:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RunException</span></code>(*args[, state])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RunnerExecuteError</span></code>(*args[, futures])</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<p><strong>Classes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Runner</span></code>([server_address, id, name, labels])</p></td>
<td><p>Base runner class, intended to be the state manager of runnable object like flow and task.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RunnerExecutor</span></code>([context])</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<p><strong>Functions:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">call_state_change_handlers</span></code>(method)</p></td>
<td><p>A decorator checks the difference between _input and _output state of the wrapped method, if two states are not identical, trigger runner’s handle_state_change method for calling all state change handlers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">catch_to_failure</span></code>(method)</p></td>
<td><p>A decorator that wraps method into a method that automatically capture exceptions into Failure state.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_timeout_signal</span></code>(timeout, func, *args, …)</p></td>
<td><p>Run function in main thread in unix system with timeout using SIGALARM signal.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_timeout_thread</span></code>(timeout, *args, **kwargs)</p></td>
<td><p>Run the task within timeout within a thread pool.</p></td>
</tr>
</tbody>
</table>
<dl class="exception">
<dt id="flowsaber.core.engine.runner.RunException">
<em class="property">exception </em><code class="sig-prename descclassname">flowsaber.core.engine.runner.</code><code class="sig-name descname">RunException</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">state: flowsaber.core.utility.state.State = None</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.engine.runner.RunException" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="flowsaber.core.engine.runner.Runner">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.engine.runner.</code><code class="sig-name descname">Runner</code><span class="sig-paren">(</span><em class="sig-param">server_address: str = None</em>, <em class="sig-param">id: str = None</em>, <em class="sig-param">name: str = None</em>, <em class="sig-param">labels: list = None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.engine.runner.Runner" title="Permalink to this definition">¶</a></dt>
<dd><p>Base runner class, intended to be the state manager of runnable object like flow and task.</p>
<p>Users need to add state change handlers in order to be informed when meeting state changes of some method.
Methods of runner should both accept and return state, and need to be decorated with
<cite>call_state_change_handlers</cite> decorator.</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">handle_state_change</span></code>(prev_state, cur_state)</p></td>
<td><p>Call all registered state change handlers with parameter of old_state and new_state.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">send_logs</span></code>()</p></td>
<td><p>This should be ran in runner.executor’s async main loop</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_run_state</span></code>()</p></td>
<td><p>Does not use create_task as these jobs has a strict order</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.engine.runner.Runner.handle_state_change">
<code class="sig-name descname">handle_state_change</code><span class="sig-paren">(</span><em class="sig-param">prev_state</em>, <em class="sig-param">cur_state</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.engine.runner.Runner.handle_state_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Call all registered state change handlers with parameter of old_state and new_state.</p>
<p>prev_state
cur_state</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.engine.runner.Runner.send_logs">
<code class="sig-name descname">send_logs</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Tuple[Coroutine, Callable]<a class="headerlink" href="#flowsaber.core.engine.runner.Runner.send_logs" title="Permalink to this definition">¶</a></dt>
<dd><p>This should be ran in runner.executor’s async main loop</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.engine.runner.Runner.update_run_state">
<code class="sig-name descname">update_run_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Tuple[Coroutine, Callable]<a class="headerlink" href="#flowsaber.core.engine.runner.Runner.update_run_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Does not use create_task as these jobs has a strict order</p>
<p>runner</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="flowsaber.core.engine.runner.RunnerExecuteError">
<em class="property">exception </em><code class="sig-prename descclassname">flowsaber.core.engine.runner.</code><code class="sig-name descname">RunnerExecuteError</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">futures=None</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.engine.runner.RunnerExecuteError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="flowsaber.core.engine.runner.RunnerExecutor">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.engine.runner.</code><code class="sig-name descname">RunnerExecutor</code><span class="sig-paren">(</span><em class="sig-param">context=&lt;class 'dict'&gt;</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.engine.runner.RunnerExecutor" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Miscellaneous:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">DoneException</span></code></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">join</span></code>([timeout])</p></td>
<td><p>Wait until the thread terminates.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">main_loop</span></code>()</p></td>
<td><p>Endlessly fetch async task anc schedule for running in asyncio envent loop untill some task raise an exception.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code>()</p></td>
<td><p>Method representing the thread’s activity.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">start</span></code>()</p></td>
<td><p>Start the thread’s activity.</p></td>
</tr>
</tbody>
</table>
<dl class="exception">
<dt id="flowsaber.core.engine.runner.RunnerExecutor.DoneException">
<em class="property">exception </em><code class="sig-name descname">DoneException</code><a class="headerlink" href="#flowsaber.core.engine.runner.RunnerExecutor.DoneException" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="flowsaber.core.engine.runner.RunnerExecutor.join">
<code class="sig-name descname">join</code><span class="sig-paren">(</span><em class="sig-param">timeout: Optional[float] = Ellipsis</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#flowsaber.core.engine.runner.RunnerExecutor.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until the thread terminates.</p>
<p>This blocks the calling thread until the thread whose join() method is
called terminates – either normally or through an unhandled exception
or until the optional timeout occurs.</p>
<p>When the timeout argument is present and not None, it should be a
floating point number specifying a timeout for the operation in seconds
(or fractions thereof). As join() always returns None, you must call
is_alive() after join() to decide whether a timeout happened – if the
thread is still alive, the join() call timed out.</p>
<p>When the timeout argument is not present or None, the operation will
block until the thread terminates.</p>
<p>A thread can be join()ed many times.</p>
<p>join() raises a RuntimeError if an attempt is made to join the current
thread as that would cause a deadlock. It is also an error to join() a
thread before it has been started and attempts to do so raises the same
exception.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.engine.runner.RunnerExecutor.main_loop">
<em class="property">async </em><code class="sig-name descname">main_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.engine.runner.RunnerExecutor.main_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Endlessly fetch async task anc schedule for running in asyncio envent loop untill some task raise an
exception.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.engine.runner.RunnerExecutor.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.engine.runner.RunnerExecutor.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Method representing the thread’s activity.</p>
<p>You may override this method in a subclass. The standard run() method
invokes the callable object passed to the object’s constructor as the
target argument, if any, with sequential and keyword arguments taken
from the args and kwargs arguments, respectively.</p>
</dd></dl>

<dl class="method">
<dt id="flowsaber.core.engine.runner.RunnerExecutor.start">
<code class="sig-name descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#flowsaber.core.engine.runner.RunnerExecutor.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the thread’s activity.</p>
<p>It must be called at most once per thread object. It arranges for the
object’s run() method to be invoked in a separate thread of control.</p>
<p>This method will raise a RuntimeError if called more than once on the
same thread object.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="flowsaber.core.engine.runner.call_state_change_handlers">
<code class="sig-prename descclassname">flowsaber.core.engine.runner.</code><code class="sig-name descname">call_state_change_handlers</code><span class="sig-paren">(</span><em class="sig-param">method: Callable[[...], flowsaber.core.utility.state.State]</em><span class="sig-paren">)</span> &#x2192; Callable[[...], flowsaber.core.utility.state.State]<a class="headerlink" href="#flowsaber.core.engine.runner.call_state_change_handlers" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator checks the difference between _input and _output state of the wrapped method, if two states are
not identical, trigger runner’s handle_state_change method for calling all state change handlers.</p>
<p>method</p>
</dd></dl>

<dl class="function">
<dt id="flowsaber.core.engine.runner.catch_to_failure">
<code class="sig-prename descclassname">flowsaber.core.engine.runner.</code><code class="sig-name descname">catch_to_failure</code><span class="sig-paren">(</span><em class="sig-param">method: Callable[[...], flowsaber.core.utility.state.State]</em><span class="sig-paren">)</span> &#x2192; Callable[[...], flowsaber.core.utility.state.State]<a class="headerlink" href="#flowsaber.core.engine.runner.catch_to_failure" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator that wraps method into a method that automatically capture exceptions into Failure state.</p>
<p>method</p>
</dd></dl>

<dl class="function">
<dt id="flowsaber.core.engine.runner.run_timeout_signal">
<code class="sig-prename descclassname">flowsaber.core.engine.runner.</code><code class="sig-name descname">run_timeout_signal</code><span class="sig-paren">(</span><em class="sig-param">timeout: int</em>, <em class="sig-param">func: Callable</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.engine.runner.run_timeout_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Run function in main thread in unix system with timeout using SIGALARM signal.</p>
<p><a class="reference external" href="https://github.com/pnpnpn/timeout-decorator/blob/master/timeout_decorator/timeout_decorator.py">https://github.com/pnpnpn/timeout-decorator/blob/master/timeout_decorator/timeout_decorator.py</a></p>
<p>func
timeout
args
kwargs</p>
</dd></dl>

<dl class="function">
<dt id="flowsaber.core.engine.runner.run_timeout_thread">
<code class="sig-prename descclassname">flowsaber.core.engine.runner.</code><code class="sig-name descname">run_timeout_thread</code><span class="sig-paren">(</span><em class="sig-param">timeout: int</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.engine.runner.run_timeout_thread" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the task within timeout within a thread pool. Note that the flowsaber.context would be corrupted
in the new thread.</p>
<p>func
timeout
kwargs</p>
</dd></dl>

</div>
<div class="section" id="module-flowsaber.core.engine.task_runner">
<span id="task-runner"></span><h2>task_runner<a class="headerlink" href="#module-flowsaber.core.engine.task_runner" title="Permalink to this headline">¶</a></h2>
<p><strong>Classes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">TaskRunner</span></code>(task, inputs, **kwargs)</p></td>
<td><p>The task runner moves the task state forward through a complicated process including: retry, cache read/write, skip, drop …</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="flowsaber.core.engine.task_runner.TaskRunner">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.engine.task_runner.</code><code class="sig-name descname">TaskRunner</code><span class="sig-paren">(</span><em class="sig-param">task: Task</em>, <em class="sig-param">inputs: inspect.BoundArguments</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.engine.task_runner.TaskRunner" title="Permalink to this definition">¶</a></dt>
<dd><p>The task runner moves the task state forward through a complicated process including:
retry, cache read/write, skip, drop …</p>
<p><strong>Methods:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_task_timeout</span></code>(**kwargs)</p></td>
<td><p>Call task.run with timeout handling by using signal.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flowsaber.core.engine.task_runner.TaskRunner.run_task_timeout">
<code class="sig-name descname">run_task_timeout</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.engine.task_runner.TaskRunner.run_task_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Call task.run with timeout handling by using signal.
Parameters
———-
kwargs</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-flowsaber.core.engine.flow_runner">
<span id="flow-runner"></span><h2>flow_runner<a class="headerlink" href="#module-flowsaber.core.engine.flow_runner" title="Permalink to this headline">¶</a></h2>
<p><strong>Classes:</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">FlowRunner</span></code>(flow, **kwargs)</p></td>
<td><p>Aimed for executing flow and maintaining/recording/responding state changes of the flow.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="flowsaber.core.engine.flow_runner.FlowRunner">
<em class="property">class </em><code class="sig-prename descclassname">flowsaber.core.engine.flow_runner.</code><code class="sig-name descname">FlowRunner</code><span class="sig-paren">(</span><em class="sig-param">flow: flowsaber.core.flow.Flow</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#flowsaber.core.engine.flow_runner.FlowRunner" title="Permalink to this definition">¶</a></dt>
<dd><p>Aimed for executing flow and maintaining/recording/responding state changes of the flow.</p>
</dd></dl>

</div>
<div class="section" id="module-flowsaber.server.database.models">
<span id="models"></span><h2>models<a class="headerlink" href="#module-flowsaber.server.database.models" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="internal.html" class="btn btn-neutral float-left" title="Internal" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, bakezq.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXX-1', 'auto');
    
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>